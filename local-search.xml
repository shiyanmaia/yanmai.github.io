<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>13种Vue修饰符</title>
    <link href="/2021/07/07/v-model/"/>
    <url>/2021/07/07/v-model/</url>
    
    <content type="html"><![CDATA[<ol><li><p>lazy</p><p><code>lazy</code>修饰符作用是，改变输入框的值时value不会改变，当光标离开输入框时，<code>v-model</code>绑定的值value才会改变</p><input type="text" v-model.lazy="value"></li><li><p>trim</p><p><code>trim</code>修饰符的作用类似于JavaScript中的<code>trim()</code>方法，作用是把<code>v-model</code>绑定的值的首尾空格给过滤掉。</p></li><li><p>number</p><p><code>number</code>修饰符的作用是将值转成数字，但是先输入字符串和先输入数字，是两种情况</p><input type="text" v-model.number="value"><p>先输入数字的话，只取前面数字部分</p><p>先输入字母的话，<code>number</code>修饰符无效</p></li><li><p>stop</p><p><code>stop</code>修饰符的作用是阻止冒泡</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;clickEvent(2)&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:300px;height:100px;background:red&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.stop</span>=<span class="hljs-string">&quot;clickEvent(1)&quot;</span>&gt;</span>点击<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></li><li><p>capture</p><p>事件默认是由里往外<code>冒泡</code>，<code>capture</code>修饰符的作用是反过来，由外网内<code>捕获</code></p></li><li><p>self</p><p><code>self</code>修饰符作用是，只有点击事件绑定的本身才会触发事件</p></li><li><p>once</p><p><code>once</code>修饰符的作用是，事件只执行一次</p></li><li><p>prevent</p><p><code>prevent</code>修饰符的作用是阻止默认事件（例如a标签的跳转）</p></li><li><p>native</p><p><code>native</code>修饰符是加在自定义组件的事件上，保证事件能执行</p></li><li><p>left，right，middle<br>这三个修饰符是鼠标的左中右按键触发的事件</p><p>&lt;button @click.middle=”clickEvent(1)”  @click.left=”clickEvent(2)”  @click.right=”clickEvent(3)”&gt;点我</p></li><li><p>passive<br>当我们在监听元素滚动事件的时候，会一直触发onscroll事件，在pc端是没啥问题的，但是在移动端，会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给onscroll事件整了一个.lazy修饰符</p></li><li><p>camel<br>不加camel viewBox会被识别成viewbox</p><p><code>&lt;svg :viewBox=&quot;viewBox&quot;&gt;&lt;/svg&gt;</code></p><p>加了canmel viewBox才会被识别成viewBox</p><p><code>&lt;svg :viewBox.camel=&quot;viewBox&quot;&gt;&lt;/svg&gt;</code></p></li><li><p>sync<br>当父组件传值进子组件，子组件想要改变这个值时，可以这么做</p><pre><code class="hljs js"><span class="hljs-comment">//父组件里</span>&lt;children :foo=<span class="hljs-string">&quot;bar&quot;</span> @update:foo=<span class="hljs-string">&quot;val =&gt; bar = val&quot;</span>&gt;&lt;/children&gt;<span class="hljs-comment">//子组件里</span><span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;update:foo&#x27;</span>, newValue)<span class="hljs-comment">//sync修饰符的作用就是，可以简写：</span><span class="hljs-comment">//父组件里</span>&lt;children :foo.sync=<span class="hljs-string">&quot;bar&quot;</span>&gt;&lt;/children&gt;<span class="hljs-comment">//子组件里</span><span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;update:foo&#x27;</span>, newValue)</code></pre></li><li><p>keyCode<br>当我们这么写事件的时候，无论按什么按钮都会触发事件<br><code>&lt;input type=&quot;text&quot; @keyup=&quot;shout(4)&quot;&gt;</code><br>那么想要限制成某个按键触发怎么办？这时候keyCode修饰符就派上用场了<br><code>&lt;input type=&quot;text&quot; @keyup.keyCode=&quot;shout(4)&quot;&gt;</code></p><pre><code class="hljs stylus">Vue提供的keyCode：<span class="hljs-comment">//普通键</span><span class="hljs-selector-class">.enter</span> .tab<span class="hljs-selector-class">.delete</span> <span class="hljs-comment">//(捕获“删除”和“退格”键)</span>.space.esc.up.down.<span class="hljs-attribute">left</span>.<span class="hljs-attribute">right</span><span class="hljs-comment">//系统修饰键</span>.ctrl.alt.meta.shift按 ctrl 才会触发&lt;<span class="hljs-selector-tag">input</span> type=<span class="hljs-string">&quot;text&quot;</span> @keyup.ctrl=<span class="hljs-string">&quot;shout(4)&quot;</span>&gt;也可以鼠标事件+按键&lt;<span class="hljs-selector-tag">input</span> type=<span class="hljs-string">&quot;text&quot;</span> @mousedown<span class="hljs-selector-class">.ctrl</span>.=<span class="hljs-string">&quot;shout(4)&quot;</span>&gt;可以多按键触发 例如 ctrl + <span class="hljs-number">67</span>&lt;<span class="hljs-selector-tag">input</span> type=<span class="hljs-string">&quot;text&quot;</span> @keyup<span class="hljs-selector-class">.ctrl</span>.<span class="hljs-number">67</span>=<span class="hljs-string">&quot;shout(4)&quot;</span>&gt;</code></pre></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript动画库</title>
    <link href="/2021/07/07/%E5%8A%A8%E6%80%81%E7%89%B9%E6%95%88/"/>
    <url>/2021/07/07/%E5%8A%A8%E6%80%81%E7%89%B9%E6%95%88/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="https://mojs.github.io/" target="_blank" rel="noopener">Mo.js</a>是一个优秀的库，可以为你的网站添加基于JavaScript的动态图形。它的速度非常快，能产生流畅的动画，在各种设备上看起来都很好。它是模块化的，所以如果你只想使用特定的组件，你可以避免额外的开销。</li></ul><a id="more"></a><ul><li><a href="https://github.com/juliangarnier/anime" target="_blank" rel="noopener">Anime</a>是GitHub上最受欢迎的动画库之一。它非常轻量级，并且带有简单易学的API。该库可用于为CSS属性、SVG和DOM属性制作动画。</li><li><a href="https://popmotion.io/" target="_blank" rel="noopener">Popmotion</a>是另一个轻量级和流行的动画库。你可以用它来制作数字、颜色和复杂字符串的动画。该库的主要动画功能只有5kb左右，整个库的容量在12kb左右。</li><li>当你想在元素滚入或滚出视口时为其制作动画时，<a href="https://scrollrevealjs.org/" target="_blank" rel="noopener">ScrollReveal库</a>就很方便。</li><li><a href="https://maxwellito.github.io/vivus/" target="_blank" rel="noopener">Vivus</a>是一个惊人的基于JavaScript的动画库，它被创建为专门为SVG制作动画。它是非常轻量级的，没有任何依赖性。</li><li>从<a href="https://github.com/mattboldt/typed.js" target="_blank" rel="noopener">Typed.js</a>这个名字你可以猜到，这个动画库是用来输入文字的。你可以把你想输入的所有字符串作为一个数组来传递。这个库还实现了一个对SEO更友好的方法，你想用打字做动画的文本可以从网页上的一个HTML<code>div</code> 读取。</li><li><a href="https://kimmobrunfeldt.github.io/progressbar.js/" target="_blank" rel="noopener">ProgressBar.js</a>库使开发者可以非常容易地在他们的网站上添加时尚的进度条。除了用一些内置的形状如直线、圆或半圆来创建进度条，你还可以选择使用你自己的自定义形状。这开辟了一堆有趣的可能性。</li><li><a href="http://airbnb.io/lottie/#/" target="_blank" rel="noopener">AirBnB的Lottie是</a>一个到目前为止我们所讨论的其他动画库中的一个。它解析了由Adobe After Effects创建的动画，这些动画已经用Bodymovin导出为JSON。之后你可以直接在你的网页上渲染这些效果。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>三种前端实现VR全景看房的方案</title>
    <link href="/2021/07/07/ar%E5%B1%95%E7%A4%BA/"/>
    <url>/2021/07/07/ar%E5%B1%95%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<p>三种前端实现VR全景看房的方案</p><p><a href="https://juejin.cn/post/6973865268426571784" target="_blank" rel="noopener">https://juejin.cn/post/6973865268426571784</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Naive UI和icon库</title>
    <link href="/2021/06/15/icon%E5%BA%93/"/>
    <url>/2021/06/15/icon%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>最近发现一个组件库叫naiveui，发现组件还挺丰富的，官网地址：<a href="https://www.naiveui.com/zh-CN/os-theme" target="_blank" rel="noopener">https://www.naiveui.com/zh-CN/light</a></p><p>icon组件库 xicons <a href="https://www.xicons.org/#/" target="_blank" rel="noopener">www.xicons.org/#/</a></p><p><strong>Unicon</strong>是一种大胆的、新的方式来设计你的网站。有4500多个图标可供选择，这个库包括社交图标、股票、产品网站的图标，以及更多！。它们很容易在任何地方使用，无论是在Sketch、Photoshop还是Illustrator中。Unicons是一个可以为你节省时间和麻烦的软件包。<a href="https://iconscout.com/unicons" target="_blank" rel="noopener">来源</a></p><p><strong>Boxicons</strong>是一个免费的矢量图标集，适用于设计UI、品牌、营销、标志和网络。它有四种格式，字体文件、SVG、CSS和PNG。该集由大量的图标组成，并有变化，因此可以为任何出现的项目做好准备。</p><p><a href="https://boxicons.com/" target="_blank" rel="noopener">来源</a></p><p><strong>Glyphs</strong>图标，你就可以接触到成千上万的图标，而且它们都是完全可编辑的。这意味着你可以定制你的图标的外观和感觉，以完美匹配你的品牌。你会得到1500多个已分类、易于使用和完全可编辑的glyphs图标。</p><p><a href="https://glyphs.fyi/" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>el-select大数据量渲染慢导致页面卡顿的问题</title>
    <link href="/2021/06/11/data%E8%BF%87%E5%A4%9A/"/>
    <url>/2021/06/11/data%E8%BF%87%E5%A4%9A/</url>
    
    <content type="html"><![CDATA[<p>一次性渲染大量数据问题</p><a id="more"></a><pre><code class="hljs js">&lt;template&gt;    &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;content&quot;</span>&gt;         &lt;el-select v-model=<span class="hljs-string">&quot;choose&quot;</span> size=<span class="hljs-string">&quot;small&quot;</span> v-el-select-loadmore:rangeNumber=<span class="hljs-string">&quot;loadMore(rangeNumber)&quot;</span>&gt;             &lt;el-option             v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;(item, index) in list.slice(0, rangeNumber)&quot;</span>              :key=<span class="hljs-string">&quot;index&quot;</span>             :label=<span class="hljs-string">&quot;item.label&quot;</span>             :value=<span class="hljs-string">&quot;item.value&quot;</span>&gt;&lt;/el-option&gt;         &lt;/el-select&gt;    &lt;/div&gt;&lt;/template&gt; &lt;script&gt;<span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;Vue.directive(    <span class="hljs-string">&#x27;el-select-loadmore&#x27;</span>, &#123;        <span class="hljs-function"><span class="hljs-title">bind</span>(<span class="hljs-params">el, binding</span>)</span> &#123;            <span class="hljs-keyword">let</span> self = <span class="hljs-built_in">this</span>            <span class="hljs-comment">// 获取element-ui定义好的scroll盒子</span>            <span class="hljs-keyword">const</span> SELECTWRAP_DOM = el.querySelector(<span class="hljs-string">&#x27;.el-select-dropdown .el-select-dropdown__wrap&#x27;</span>);            SELECTWRAP_DOM.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;                <span class="hljs-comment">/**</span><span class="hljs-comment">                * scrollHeight 获取元素内容高度(只读)</span><span class="hljs-comment">                * scrollTop 获取或者设置元素的偏移值,常用于, 计算滚动条的位置, 当一个元素的容器没有产生垂直方向的滚动条, 那它的scrollTop的值默认为0.</span><span class="hljs-comment">                * clientHeight 读取元素的可见高度(只读)</span><span class="hljs-comment">                * 如果元素滚动到底, 下面等式返回true, 没有则返回false:</span><span class="hljs-comment">                * ele.scrollHeight - ele.scrollTop === ele.clientHeight;</span><span class="hljs-comment">                */</span>                <span class="hljs-keyword">const</span> condition = <span class="hljs-built_in">this</span>.scrollHeight - <span class="hljs-built_in">this</span>.scrollTop &lt;= <span class="hljs-built_in">this</span>.clientHeight;                <span class="hljs-keyword">if</span> (condition) binding.value()            &#125;);        &#125;    &#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> &#123;           list: [],           choose: <span class="hljs-string">&quot;&quot;</span>,           rangeNumber: <span class="hljs-number">10</span>,        &#125;    &#125;,    <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span>&#123;       <span class="hljs-built_in">this</span>.getList()    &#125;,    methods: &#123;        <span class="hljs-function"><span class="hljs-title">getList</span>(<span class="hljs-params"></span>)</span>&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++)&#123;                <span class="hljs-built_in">this</span>.list.push(&#123;                   label: <span class="hljs-string">&quot;menu&quot;</span>,                   value: <span class="hljs-string">&quot;menu&quot;</span>                &#125;)            &#125;<span class="hljs-comment">//测试数据10万条数据, 这里数据多少条无所谓,list.slice(0, rangeNumber)方法只会默认加载初始的10条数据</span>        &#125;,        <span class="hljs-function"><span class="hljs-title">loadMore</span>(<span class="hljs-params">n</span>)</span>&#123;            <span class="hljs-comment">//n是默认初始展示的条数会在渲染的时候就可以获取,具体可以打log查看</span>            <span class="hljs-comment">//if(n &lt; 8) this.rangeNumber = 10 //elementui下拉超过7条才会出滚动条,如果初始不出滚动条无法触发loadMore方法</span>            <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.rangeNumber += <span class="hljs-number">5</span> <span class="hljs-comment">//每次滚动到底部可以新增条数  可自定义</span>        &#125;,    &#125;&#125;&lt;/script&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端性能优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>js如何少写if else</title>
    <link href="/2021/06/11/js%E4%BC%98%E9%9B%85%E5%88%A4%E6%96%AD/"/>
    <url>/2021/06/11/js%E4%BC%98%E9%9B%85%E5%88%A4%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 按钮点击事件</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消</span><span class="hljs-comment"> */</span><span class="hljs-keyword">const</span> onButtonClick = <span class="hljs-function">(<span class="hljs-params">status</span>)=&gt;</span>&#123;    <span class="hljs-keyword">if</span>(status == <span class="hljs-number">1</span>)&#123;        sendLog(<span class="hljs-string">&#x27;processing&#x27;</span>)        jumpTo(<span class="hljs-string">&#x27;IndexPage&#x27;</span>)    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(status == <span class="hljs-number">2</span>)&#123;        sendLog(<span class="hljs-string">&#x27;fail&#x27;</span>)        jumpTo(<span class="hljs-string">&#x27;FailPage&#x27;</span>)    &#125;</code></pre><p>改为switch的模式</p><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 按钮点击事件</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消</span><span class="hljs-comment"> */</span><span class="hljs-keyword">const</span> onButtonClick = <span class="hljs-function">(<span class="hljs-params">status</span>)=&gt;</span>&#123;    <span class="hljs-keyword">switch</span> (status)&#123;        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:            sendLog(<span class="hljs-string">&#x27;processing&#x27;</span>)            jumpTo(<span class="hljs-string">&#x27;IndexPage&#x27;</span>)            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:            sendLog(<span class="hljs-string">&#x27;fail&#x27;</span>)            jumpTo(<span class="hljs-string">&#x27;FailPage&#x27;</span>)            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">default</span>:            sendLog(<span class="hljs-string">&#x27;other&#x27;</span>)            jumpTo(<span class="hljs-string">&#x27;Index&#x27;</span>)            <span class="hljs-keyword">break</span>    &#125;</code></pre><p>case 2和case 3逻辑一样的时候，可以省去执行语句和break，则case 2的情况自动执行case 3的逻辑。</p><p>再次简化</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> actions = &#123;    <span class="hljs-string">&#x27;1&#x27;</span>: [<span class="hljs-string">&#x27;processing&#x27;</span>,<span class="hljs-string">&#x27;IndexPage&#x27;</span>],    <span class="hljs-string">&#x27;2&#x27;</span>: [<span class="hljs-string">&#x27;fail&#x27;</span>,<span class="hljs-string">&#x27;FailPage&#x27;</span>],    <span class="hljs-string">&#x27;3&#x27;</span>: [<span class="hljs-string">&#x27;fail&#x27;</span>,<span class="hljs-string">&#x27;FailPage&#x27;</span>],    <span class="hljs-string">&#x27;4&#x27;</span>: [<span class="hljs-string">&#x27;success&#x27;</span>,<span class="hljs-string">&#x27;SuccessPage&#x27;</span>],    <span class="hljs-string">&#x27;5&#x27;</span>: [<span class="hljs-string">&#x27;cancel&#x27;</span>,<span class="hljs-string">&#x27;CancelPage&#x27;</span>],    <span class="hljs-string">&#x27;default&#x27;</span>: [<span class="hljs-string">&#x27;other&#x27;</span>,<span class="hljs-string">&#x27;Index&#x27;</span>],&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 按钮点击事件</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>status 活动状态：1开团进行中 2开团失败 3 商品售罄 4 开团成功 5 系统取消</span><span class="hljs-comment"> */</span><span class="hljs-keyword">const</span> onButtonClick = <span class="hljs-function">(<span class="hljs-params">status</span>)=&gt;</span>&#123;    <span class="hljs-keyword">let</span> action = actions[status] || actions[<span class="hljs-string">&#x27;default&#x27;</span>],        logName = action[<span class="hljs-number">0</span>],        pageName = action[<span class="hljs-number">1</span>]    sendLog(logName)    jumpTo(pageName)&#125;</code></pre><p>再次优化</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> actions = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([    [<span class="hljs-number">1</span>, [<span class="hljs-string">&#x27;processing&#x27;</span>,<span class="hljs-string">&#x27;IndexPage&#x27;</span>]],    [<span class="hljs-number">2</span>, [<span class="hljs-string">&#x27;fail&#x27;</span>,<span class="hljs-string">&#x27;FailPage&#x27;</span>]],    [<span class="hljs-number">3</span>, [<span class="hljs-string">&#x27;fail&#x27;</span>,<span class="hljs-string">&#x27;FailPage&#x27;</span>]],    [<span class="hljs-number">4</span>, [<span class="hljs-string">&#x27;success&#x27;</span>,<span class="hljs-string">&#x27;SuccessPage&#x27;</span>]],    [<span class="hljs-number">5</span>, [<span class="hljs-string">&#x27;cancel&#x27;</span>,<span class="hljs-string">&#x27;CancelPage&#x27;</span>]],    [<span class="hljs-string">&#x27;default&#x27;</span>, [<span class="hljs-string">&#x27;other&#x27;</span>,<span class="hljs-string">&#x27;Index&#x27;</span>]]])<span class="hljs-comment">/**</span><span class="hljs-comment"> * 按钮点击事件</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消</span><span class="hljs-comment"> */</span><span class="hljs-keyword">const</span> onButtonClick = <span class="hljs-function">(<span class="hljs-params">status</span>)=&gt;</span>&#123;    <span class="hljs-keyword">let</span> action = actions.get(status) || actions.get(<span class="hljs-string">&#x27;default&#x27;</span>)    sendLog(action[<span class="hljs-number">0</span>])    jumpTo(action[<span class="hljs-number">1</span>])&#125;</code></pre><p>Map对象和Object对象有什么区别呢？</p><ol><li>一个对象通常都有自己的原型，所以一个对象总有一个”prototype”键。</li><li>一个对象的键只能是字符串或者Symbols，但一个Map的键可以是任意值。</li><li>你可以通过size属性很容易地得到一个Map的键值对个数，而对象的键值对个数只能手动确认。</li></ol><p>这个时候如果有二元判断</p><pre><code class="hljs js"><span class="hljs-keyword">if</span>（<span class="hljs-number">1</span>）&#123;    <span class="hljs-keyword">if</span>（<span class="hljs-number">1</span>）&#123;        <span class="hljs-comment">//do sth</span>    &#125;&#125;</code></pre><p>可以这么做</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> actions = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([    [<span class="hljs-string">&#x27;guest_1&#x27;</span>, <span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">/*do sth*/</span>&#125;],    [<span class="hljs-string">&#x27;guest_2&#x27;</span>, <span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">/*do sth*/</span>&#125;],    [<span class="hljs-string">&#x27;guest_3&#x27;</span>, <span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">/*do sth*/</span>&#125;],    [<span class="hljs-string">&#x27;guest_4&#x27;</span>, <span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">/*do sth*/</span>&#125;],    [<span class="hljs-string">&#x27;guest_5&#x27;</span>, <span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">/*do sth*/</span>&#125;],    [<span class="hljs-string">&#x27;master_1&#x27;</span>, <span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">/*do sth*/</span>&#125;],    [<span class="hljs-string">&#x27;master_2&#x27;</span>, <span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">/*do sth*/</span>&#125;],    [<span class="hljs-string">&#x27;master_3&#x27;</span>, <span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">/*do sth*/</span>&#125;],    [<span class="hljs-string">&#x27;master_4&#x27;</span>, <span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">/*do sth*/</span>&#125;],    [<span class="hljs-string">&#x27;master_5&#x27;</span>, <span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">/*do sth*/</span>&#125;],    [<span class="hljs-string">&#x27;default&#x27;</span>, <span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">/*do sth*/</span>&#125;],])<span class="hljs-comment">/**</span><span class="hljs-comment"> * 按钮点击事件</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> </span>identity 身份标识：guest客态 master主态</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>status 活动状态：1 开团进行中 2 开团失败 3 开团成功 4 商品售罄 5 有库存未开团</span><span class="hljs-comment"> */</span><span class="hljs-keyword">const</span> onButtonClick = <span class="hljs-function">(<span class="hljs-params">identity,status</span>)=&gt;</span>&#123;    <span class="hljs-keyword">let</span> action = actions.get(<span class="hljs-string">`<span class="hljs-subst">$&#123;identity&#125;</span>_<span class="hljs-subst">$&#123;status&#125;</span>`</span>) || actions.get(<span class="hljs-string">&#x27;default&#x27;</span>)    action.call(<span class="hljs-built_in">this</span>)&#125;</code></pre><p>用Object对象来实现也是类似的，Map可以用任何类型的数据作为key。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> actions = &#123;  <span class="hljs-string">&#x27;guest_1&#x27;</span>:<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">/*do sth*/</span>&#125;,  <span class="hljs-string">&#x27;guest_2&#x27;</span>:<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">/*do sth*/</span>&#125;,  <span class="hljs-comment">//....</span>&#125;<span class="hljs-keyword">const</span> onButtonClick = <span class="hljs-function">(<span class="hljs-params">identity,status</span>)=&gt;</span>&#123;  <span class="hljs-keyword">let</span> action = actions[<span class="hljs-string">`<span class="hljs-subst">$&#123;identity&#125;</span>_<span class="hljs-subst">$&#123;status&#125;</span>`</span>] || actions[<span class="hljs-string">&#x27;default&#x27;</span>]  action.call(<span class="hljs-built_in">this</span>)&#125;</code></pre><p>假如guest情况下，status1-4的处理逻辑都一样怎么办</p><p>最差的情况是这样</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> actions = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([  [&#123;<span class="hljs-attr">identity</span>:<span class="hljs-string">&#x27;guest&#x27;</span>,<span class="hljs-attr">status</span>:<span class="hljs-number">1</span>&#125;,<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">/* functionA */</span>&#125;],  [&#123;<span class="hljs-attr">identity</span>:<span class="hljs-string">&#x27;guest&#x27;</span>,<span class="hljs-attr">status</span>:<span class="hljs-number">2</span>&#125;,<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">/* functionA */</span>&#125;],  [&#123;<span class="hljs-attr">identity</span>:<span class="hljs-string">&#x27;guest&#x27;</span>,<span class="hljs-attr">status</span>:<span class="hljs-number">3</span>&#125;,<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">/* functionA */</span>&#125;],  [&#123;<span class="hljs-attr">identity</span>:<span class="hljs-string">&#x27;guest&#x27;</span>,<span class="hljs-attr">status</span>:<span class="hljs-number">4</span>&#125;,<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">/* functionA */</span>&#125;],  [&#123;<span class="hljs-attr">identity</span>:<span class="hljs-string">&#x27;guest&#x27;</span>,<span class="hljs-attr">status</span>:<span class="hljs-number">5</span>&#125;,<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">/* functionB */</span>&#125;],  <span class="hljs-comment">//...</span>])</code></pre><p>好一点的写法是将处理逻辑函数进行缓存</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> actions = <span class="hljs-function">()=&gt;</span>&#123;  <span class="hljs-keyword">const</span> functionA = <span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">/*do sth*/</span>&#125;  <span class="hljs-keyword">const</span> functionB = <span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">/*do sth*/</span>&#125;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([    [&#123;<span class="hljs-attr">identity</span>:<span class="hljs-string">&#x27;guest&#x27;</span>,<span class="hljs-attr">status</span>:<span class="hljs-number">1</span>&#125;,functionA],    [&#123;<span class="hljs-attr">identity</span>:<span class="hljs-string">&#x27;guest&#x27;</span>,<span class="hljs-attr">status</span>:<span class="hljs-number">2</span>&#125;,functionA],    [&#123;<span class="hljs-attr">identity</span>:<span class="hljs-string">&#x27;guest&#x27;</span>,<span class="hljs-attr">status</span>:<span class="hljs-number">3</span>&#125;,functionA],    [&#123;<span class="hljs-attr">identity</span>:<span class="hljs-string">&#x27;guest&#x27;</span>,<span class="hljs-attr">status</span>:<span class="hljs-number">4</span>&#125;,functionA],    [&#123;<span class="hljs-attr">identity</span>:<span class="hljs-string">&#x27;guest&#x27;</span>,<span class="hljs-attr">status</span>:<span class="hljs-number">5</span>&#125;,functionB],    <span class="hljs-comment">//...</span>  ])&#125;<span class="hljs-keyword">const</span> onButtonClick = <span class="hljs-function">(<span class="hljs-params">identity,status</span>)=&gt;</span>&#123;  <span class="hljs-keyword">let</span> action = [...actions()].filter(<span class="hljs-function">(<span class="hljs-params">[key,value]</span>)=&gt;</span>(key.identity == identity &amp;&amp; key.status == status))  action.forEach(<span class="hljs-function">(<span class="hljs-params">[key,value]</span>)=&gt;</span>value.call(<span class="hljs-built_in">this</span>))&#125;</code></pre><p>优化</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> actions = <span class="hljs-function">()=&gt;</span>&#123;  <span class="hljs-keyword">const</span> functionA = <span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">/*do sth*/</span>&#125;  <span class="hljs-keyword">const</span> functionB = <span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">/*do sth*/</span>&#125;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([    [<span class="hljs-regexp">/^guest_[1-4]$/</span>,functionA],    [<span class="hljs-regexp">/^guest_5$/</span>,functionB],    <span class="hljs-comment">//...</span>  ])&#125;<span class="hljs-keyword">const</span> onButtonClick = <span class="hljs-function">(<span class="hljs-params">identity,status</span>)=&gt;</span>&#123;  <span class="hljs-keyword">let</span> action = [...actions()].filter(<span class="hljs-function">(<span class="hljs-params">[key,value]</span>)=&gt;</span>(key.test(<span class="hljs-string">`<span class="hljs-subst">$&#123;identity&#125;</span>_<span class="hljs-subst">$&#123;status&#125;</span>`</span>)))  action.forEach(<span class="hljs-function">(<span class="hljs-params">[key,value]</span>)=&gt;</span>value.call(<span class="hljs-built_in">this</span>))&#125;</code></pre><p>假如需求变成，凡是guest情况都要发送一个日志埋点，不同status情况也需要单独的逻辑处理，那我们可以这样写：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> actions = <span class="hljs-function">()=&gt;</span>&#123;  <span class="hljs-keyword">const</span> functionA = <span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">/*do sth*/</span>&#125;  <span class="hljs-keyword">const</span> functionB = <span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">/*do sth*/</span>&#125;  <span class="hljs-keyword">const</span> functionC = <span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">/*send log*/</span>&#125;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([    [<span class="hljs-regexp">/^guest_[1-4]$/</span>,functionA],    [<span class="hljs-regexp">/^guest_5$/</span>,functionB],    [<span class="hljs-regexp">/^guest_.*$/</span>,functionC],    <span class="hljs-comment">//...</span>  ])&#125;<span class="hljs-keyword">const</span> onButtonClick = <span class="hljs-function">(<span class="hljs-params">identity,status</span>)=&gt;</span>&#123;  <span class="hljs-keyword">let</span> action = [...actions()].filter(<span class="hljs-function">(<span class="hljs-params">[key,value]</span>)=&gt;</span>(key.test(<span class="hljs-string">`<span class="hljs-subst">$&#123;identity&#125;</span>_<span class="hljs-subst">$&#123;status&#125;</span>`</span>)))  action.forEach(<span class="hljs-function">(<span class="hljs-params">[key,value]</span>)=&gt;</span>value.call(<span class="hljs-built_in">this</span>))&#125;</code></pre><p>总结</p><p>8种逻辑判断写法，包括：</p><ol><li><p>if/else</p></li><li><p>switch</p></li><li><p>一元判断时：存到Object里</p></li><li><p>一元判断时：存到Map里</p></li><li><p>多元判断时：将condition拼接成字符串存到Object里</p></li><li><p>多元判断时：将condition拼接成字符串存到Map里</p></li><li><p>多元判断时：将condition存为Object存到Map里</p></li><li><p>多元判断时：将condition写作正则存到Map里</p></li></ol><p>原文：<a href="https://juejin.cn/post/6844903705058213896" target="_blank" rel="noopener">https://juejin.cn/post/6844903705058213896</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vue-ifranme局部打印插件</title>
    <link href="/2021/06/09/vue%E5%B0%8F%E6%8F%92%E4%BB%B6/"/>
    <url>/2021/06/09/vue%E5%B0%8F%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>vue-iframe-print</p><p>基于 iframe 打印的小工具</p><a id="more"></a><p><a href="https://github.com/alexwjj/vue-iframe-print" target="_blank" rel="noopener">https://github.com/alexwjj/vue-iframe-print</a></p><p><a href="https://github.com/1014156094/vue-cert-poster" target="_blank" rel="noopener">vue-cert-poster</a></p><p>稍加修改即可自用，主要使用的是html2canvas，如何解决用户缩放浏览器的问题，这里是转换成base64图片，最后下载输出，可以防止html2canvas制作的时候比例不对的问题。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>10分钟实现微信 &quot;炸屎&quot;大作战</title>
    <link href="/2021/06/04/ShitBomb/"/>
    <url>/2021/06/04/ShitBomb/</url>
    
    <content type="html"><![CDATA[<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1.<strong>丢炸弹</strong></p><p>轨迹路径（类似 y = x2x^2x2 ），然后通过<code>tween.js</code>来做补间动画。</p><a id="more"></a><p>2.<strong>炸弹爆炸</strong></p><p>利用<code>lottie</code> 来实现动画。</p><p>3.<strong>粑粑被炸开</strong></p><p>利用 <code>css</code> 动画实现</p><p>4.<strong>所有人震动</strong></p><p>利用 <code>css</code> 动画实现</p><hr><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="1-丢炸弹"><a href="#1-丢炸弹" class="headerlink" title="1.丢炸弹"></a>1.丢炸弹</h3><p>现在假设我们的炸弹是一个 10px * 10px 的小方块，设置起始点为（300，300）终点为 （0，100） H=100，此时我们得到的二次函数为：<br>$$<br>y=(1/120)x^2-(11/6)x+100<br>$$</p><p>而渲染每一帧动画，我们则用了著名的补间动画库<a href="http://tweenjs.github.io/tween.js" target="_blank" rel="noopener">Tween.js</a> 补间(动画)是一个概念，允许你以平滑的方式更改对象的属性。你只需告诉它哪些属性要更改，当补间结束运行时它们应该具有哪些最终值，以及这需要多长时间，补间引擎将负责计算从起始点到结束点的值。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> coords = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">300</span> &#125;;  <span class="hljs-comment">// 起始点 为 x = 300</span><span class="hljs-keyword">var</span> tween = <span class="hljs-keyword">new</span> TWEEN.Tween(coords) .to(&#123; <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>  &#125;, <span class="hljs-number">1000</span>) <span class="hljs-comment">// 终点为 x = 0, 并且这个动作将在1秒内完成</span>  .easing(TWEEN.Easing.Linear.None) <span class="hljs-comment">// 匀速</span></code></pre><p>完整demo   <a href="/demo">效果链接</a></p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>cdn-animation<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.7.0/Tween.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">            <span class="hljs-keyword">var</span> box = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);</span><span class="javascript">            box.style.setProperty(<span class="hljs-string">&#x27;width&#x27;</span>, <span class="hljs-string">&#x27;20px&#x27;</span>);</span><span class="javascript">            box.style.setProperty(<span class="hljs-string">&#x27;height&#x27;</span>, <span class="hljs-string">&#x27;20px&#x27;</span>);</span><span class="javascript">            box.style.setProperty(<span class="hljs-string">&#x27;background-position&#x27;</span>, <span class="hljs-string">&#x27;center&#x27;</span>);</span><span class="javascript">            box.style.setProperty(<span class="hljs-string">&#x27;background-size&#x27;</span>, <span class="hljs-string">&#x27;100%&#x27;</span>);</span><span class="javascript">            box.style.setProperty(<span class="hljs-string">&#x27;background-image&#x27;</span>, <span class="hljs-string">&#x27;url(./bomb.png)&#x27;</span>);</span><span class="javascript">            box.style.setProperty(<span class="hljs-string">&#x27;transform&#x27;</span>, <span class="hljs-string">&#x27;translate(&#x27;</span> + <span class="hljs-number">300</span> + <span class="hljs-string">&#x27;px, &#x27;</span> + <span class="hljs-number">300</span> + <span class="hljs-string">&#x27;px)&#x27;</span>);</span><span class="javascript">            <span class="hljs-built_in">document</span>.body.appendChild(box);</span><span class="javascript">            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">animate</span>(<span class="hljs-params">time</span>) </span>&#123;</span>                requestAnimationFrame(animate);                TWEEN.update(time);            &#125;            requestAnimationFrame(animate);<span class="javascript">            <span class="hljs-keyword">var</span> H = <span class="hljs-number">100</span>;</span><span class="javascript">            <span class="hljs-keyword">var</span> coords = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">300</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> &#125;;</span><span class="javascript">            <span class="hljs-keyword">var</span> tween = <span class="hljs-keyword">new</span> TWEEN.Tween(coords)</span>            .to(&#123; x: 0, y: 360 &#125;, 1000)            .easing(TWEEN.Easing.Linear.None)<span class="javascript">            .onUpdate(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">                <span class="hljs-keyword">var</span> c = H;</span><span class="javascript">                <span class="hljs-keyword">var</span> a = <span class="hljs-number">5</span> / (<span class="hljs-number">6</span> * H);</span><span class="javascript">                <span class="hljs-keyword">var</span> b = -<span class="hljs-number">11</span> / <span class="hljs-number">6</span>;</span><span class="javascript">                <span class="hljs-keyword">var</span> x = coords.x;</span><span class="javascript">                <span class="hljs-keyword">var</span> y = a * x * x + b * x + c;</span><span class="javascript">                <span class="hljs-built_in">console</span>.log(coords.y);</span><span class="javascript">                box.style.setProperty(<span class="hljs-string">&#x27;transform&#x27;</span>, <span class="hljs-string">`translate(<span class="hljs-subst">$&#123;x&#125;</span>px, <span class="hljs-subst">$&#123;y&#125;</span>px) rotate(<span class="hljs-subst">$&#123;coords.y&#125;</span>deg)`</span>);</span><span class="javascript">                <span class="hljs-comment">// box.style.setProperty(&#x27;transform&#x27;, `rotate($&#123;coords.y&#125;deg)`);</span></span>            &#125;)            .start();        <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h3 id="2-炸弹爆炸"><a href="#2-炸弹爆炸" class="headerlink" title="2.炸弹爆炸"></a>2.炸弹爆炸</h3><pre><code class="hljs js">&lt;script src=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/lottie-web/5.7.8/lottie.min.js&quot;</span>&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;bodymovin&quot;</span>&gt;&lt;/div&gt;&lt;script&gt;    <span class="hljs-keyword">const</span> animation = <span class="hljs-built_in">window</span>.bodymovin.loadAnimation(&#123;        container: <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.bodymovin&#x27;</span>), <span class="hljs-comment">// 要包含该动画的dom元素</span>        renderer: <span class="hljs-string">&#x27;svg&#x27;</span>, <span class="hljs-comment">// 渲染方式，svg、canvas、html（轻量版仅svg渲染）</span>        loop: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否循环播放</span>        autoplay: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否自动播放</span>        path: <span class="hljs-string">&#x27;./bomb.json&#x27;</span>, <span class="hljs-comment">// 动画json文件路径</span>    &#125;);&lt;/script&gt;</code></pre><p>因此我们只需要在抛物线完成后再立即调用爆炸特效，而<code>tween.js</code> 也给我提供了事件方法<code>onComplete</code>。我们只需要在<code>onComplete</code>回调中，让爆炸动画开始。</p><pre><code class="hljs js">tween.onComplete(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-comment">// 写爆炸动画</span>&#125;)</code></pre><h3 id="3-粑粑被炸开"><a href="#3-粑粑被炸开" class="headerlink" title="3.粑粑被炸开"></a>3.粑粑被炸开</h3><p>具体链接：<a href="https://juejin.cn/post/6969401491853410312" target="_blank" rel="noopener">https://juejin.cn/post/6969401491853410312</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>展开语法(spread syntax)</title>
    <link href="/2021/05/31/%E5%B1%95%E5%BC%80%E5%89%AF%E6%9C%AC/"/>
    <url>/2021/05/31/%E5%B1%95%E5%BC%80%E5%89%AF%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>let a = {…a}</p><p>相当于一级属性的深拷贝</p><p>let a = {…a, a.name=1}改了里面的属性，相当于合并</p><hr><pre><code class="hljs js"><span class="hljs-keyword">let</span> bar = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<span class="hljs-keyword">let</span> baz = &#123; ...bar &#125;; <span class="hljs-comment">// &#123; a: 1, b: 2 &#125;</span></code></pre><p>等价于</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> bar = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<span class="hljs-keyword">let</span> baz = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, bar); <span class="hljs-comment">// &#123; a: 1, b: 2 &#125;</span></code></pre><p>可以将数组转换为参数序列</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;  <span class="hljs-keyword">return</span> x + y;&#125;<span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">4</span>, <span class="hljs-number">38</span>];add(...numbers) <span class="hljs-comment">// 42</span></code></pre><p>扩展运算符可以与解构赋值结合起来，用于生成数组</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> [first, ...rest] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];first <span class="hljs-comment">// 1</span>rest  <span class="hljs-comment">// [2, 3, 4, 5]</span></code></pre><p><strong>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</strong></p><p>扩展运算符还可以将字符串转为真正的数组</p><pre><code class="hljs javascript">[...<span class="hljs-string">&#x27;hello&#x27;</span>]<span class="hljs-comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></code></pre><p>数据结构转为数组,比如：</p><pre><code class="hljs javascript"><span class="hljs-comment">// arguments对象</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> args = [...arguments];&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Object.assign()</title>
    <link href="/2021/05/28/object/"/>
    <url>/2021/05/28/object/</url>
    
    <content type="html"><![CDATA[<p><code>**Object.assign()**</code> 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。</p><a id="more"></a><pre><code class="hljs js"><span class="hljs-keyword">const</span> target = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<span class="hljs-keyword">const</span> source = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">5</span> &#125;;<span class="hljs-keyword">const</span> returnedTarget = <span class="hljs-built_in">Object</span>.assign(target, source);<span class="hljs-built_in">console</span>.log(target);<span class="hljs-comment">// expected output: Object &#123; a: 1, b: 4, c: 5 &#125;</span><span class="hljs-built_in">console</span>.log(returnedTarget);<span class="hljs-comment">// expected output: Object &#123; a: 1, b: 4, c: 5 &#125;</span><span class="hljs-keyword">const</span> deteleObject = <span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> uniques = []    <span class="hljs-keyword">let</span> stringify = &#123;&#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; obj.length; i++) &#123;        <span class="hljs-keyword">let</span> keys = <span class="hljs-built_in">Object</span>.keys(obj[i])        keys.sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;            <span class="hljs-keyword">return</span> (<span class="hljs-built_in">Number</span>(a) - <span class="hljs-built_in">Number</span>(b))        &#125;)        <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&#x27;</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; keys.length; j++) &#123;            str += <span class="hljs-built_in">JSON</span>.stringify(keys[j])            str += <span class="hljs-built_in">JSON</span>.stringify(obj[i][keys[j]])        &#125;        <span class="hljs-keyword">if</span> (!stringify.hasOwnProperty(str)) &#123;            uniques.push(obj[i])            stringify[str] = <span class="hljs-literal">true</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> uniques&#125;</code></pre><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><pre><code class="hljs css"><span class="hljs-selector-tag">Object</span><span class="hljs-selector-class">.assign</span>(<span class="hljs-selector-tag">target</span>, ..<span class="hljs-selector-class">.sources</span>)</code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><p><code>target</code></p><p>目标对象。</p></li><li><p><code>sources</code></p><p>源对象。</p></li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>目标对象。</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性。</p><p><code>Object.assign</code> 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的<code>[[Get]]</code>和目标对象的<code>[[Set]]</code>，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor" target="_blank" rel="noopener"><code>Object.getOwnPropertyDescriptor()</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener"><code>Object.defineProperty()</code></a> 。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String" target="_blank" rel="noopener"><code>String</code></a>类型和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank" rel="noopener"><code>Symbol</code></a> 类型的属性都会被拷贝。</p><p>在出现错误的情况下，例如，如果属性不可写，会引发<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError" target="_blank" rel="noopener"><code>TypeError</code></a>，如果在引发错误之前添加了任何属性，则可以更改<code>target</code>对象。</p><p>注意，<code>Object.assign</code> 不会在那些<code>source</code>对象值为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null" target="_blank" rel="noopener"><code>null</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="noopener"><code>undefined</code></a> 的时候抛出错误。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端去除数组中重复对象</title>
    <link href="/2021/05/24/sortquchong/"/>
    <url>/2021/05/24/sortquchong/</url>
    
    <content type="html"><![CDATA[<p>两个函数</p><a id="more"></a><pre><code class="hljs js"><span class="hljs-keyword">const</span> deteleObject = <span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> uniques = []    <span class="hljs-keyword">let</span> stringify = &#123;&#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; obj.length; i++) &#123;        <span class="hljs-keyword">let</span> keys = <span class="hljs-built_in">Object</span>.keys(obj[i])        keys.sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;            <span class="hljs-keyword">return</span> (<span class="hljs-built_in">Number</span>(a) - <span class="hljs-built_in">Number</span>(b))        &#125;)        <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&#x27;</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; keys.length; j++) &#123;            str += <span class="hljs-built_in">JSON</span>.stringify(keys[j])            str += <span class="hljs-built_in">JSON</span>.stringify(obj[i][keys[j]])        &#125;        <span class="hljs-keyword">if</span> (!stringify.hasOwnProperty(str)) &#123;            uniques.push(obj[i])            stringify[str] = <span class="hljs-literal">true</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> uniques&#125;</code></pre><p>暂未使用的方法：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> hash = &#123;&#125;arr = arr.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, next</span>) </span>&#123;     hash[next.name] ? <span class="hljs-string">&#x27;&#x27;</span> : hash[next.name] = <span class="hljs-literal">true</span> &amp;&amp; item.push(next)     <span class="hljs-keyword">return</span> item&#125;, [])</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vue-element-admin后台权限</title>
    <link href="/2021/05/19/premission-js/"/>
    <url>/2021/05/19/premission-js/</url>
    
    <content type="html"><![CDATA[<p>★主要学习文档：<a href="https://juejin.cn/post/6844903478880370701" target="_blank" rel="noopener">https://juejin.cn/post/6844903478880370701</a></p><a id="more"></a><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><hr><ul><li>创建vue实例的时候将vue-router挂载，但这个时候vue-router挂载一些登录或者不用权限的公用的页面。</li><li>当用户登录后，获取用role，将role和路由表每个页面的需要的权限作比较，生成最终用户可访问的路由表。</li><li>调用router.addRoutes(store.getters.addRouters)添加用户可访问的路由。</li><li>使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。</li></ul><h3 id="router-js"><a href="#router-js" class="headerlink" title="router.js"></a>router.js</h3><hr><p>首先我们实现router.js路由表，这里就拿前端控制路由来举例(后端存储的也差不多，稍微改造一下就好了)</p><pre><code class="hljs js"><span class="hljs-comment">// router.js</span><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<span class="hljs-keyword">import</span> Router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;<span class="hljs-keyword">import</span> Login <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../views/login/&#x27;</span>;<span class="hljs-keyword">const</span> dashboard = <span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;../views/dashboard/index&#x27;</span>], resolve);<span class="hljs-comment">//使用了vue-routerd的[Lazy Loading Routes</span>](https:<span class="hljs-comment">//router.vuejs.org/en/advanced/lazy-loading.html)</span><span class="hljs-comment">//所有权限通用路由表 </span><span class="hljs-comment">//如首页和登录页和一些不用权限的公用页面</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> constantRouterMap = [  &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/login&#x27;</span>, <span class="hljs-attr">component</span>: Login &#125;,  &#123;    path: <span class="hljs-string">&#x27;/&#x27;</span>,    component: Layout,    redirect: <span class="hljs-string">&#x27;/dashboard&#x27;</span>,    name: <span class="hljs-string">&#x27;首页&#x27;</span>,    children: [&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;dashboard&#x27;</span>, <span class="hljs-attr">component</span>: dashboard &#125;]  &#125;,]<span class="hljs-comment">//实例化vue的时候只挂载constantRouter</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Router(&#123;  routes: constantRouterMap&#125;);<span class="hljs-comment">//异步挂载的路由</span><span class="hljs-comment">//动态需要根据权限加载的路由表 </span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> asyncRouterMap = [  &#123;    path: <span class="hljs-string">&#x27;/permission&#x27;</span>,    component: Layout,    name: <span class="hljs-string">&#x27;权限测试&#x27;</span>,    meta: &#123; <span class="hljs-attr">role</span>: [<span class="hljs-string">&#x27;admin&#x27;</span>,<span class="hljs-string">&#x27;super_editor&#x27;</span>] &#125;, <span class="hljs-comment">//页面需要的权限</span>    children: [    &#123;       path: <span class="hljs-string">&#x27;index&#x27;</span>,      component: Permission,      name: <span class="hljs-string">&#x27;权限测试页&#x27;</span>,      meta: &#123; <span class="hljs-attr">role</span>: [<span class="hljs-string">&#x27;admin&#x27;</span>,<span class="hljs-string">&#x27;super_editor&#x27;</span>] &#125;  <span class="hljs-comment">//页面需要的权限</span>    &#125;]  &#125;,  &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/404&#x27;</span>, <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span> &#125;];</code></pre><p>这里我们根据 <a href="https://router.vuejs.org/en/advanced/meta.html" target="_blank" rel="noopener">vue-router官方推荐</a> 的方法通过meta标签来标示改页面能访问的权限有哪些。如<code>meta: { role: [&#39;admin&#39;,&#39;super_editor&#39;] }</code>表示该页面只有admin和超级编辑才能有资格进入。</p><p><strong>注意事项</strong>：这里有一个需要非常注意的地方就是 <code>404</code> 页面一定要最后加载，如果放在<code>constantRouterMap</code>一同声明了<code>404</code>，后面的所以页面都会被拦截到<code>404</code>，详细的问题见<a href="https://github.com/vuejs/vue-router/issues/1176" target="_blank" rel="noopener">addRoutes when you’ve got a wildcard route for 404s does not work</a></p><h3 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h3><hr><p><strong>关键的main.js</strong></p><pre><code class="hljs js"><span class="hljs-comment">// main.js</span>router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (store.getters.token) &#123; <span class="hljs-comment">// 判断是否有token</span>    <span class="hljs-keyword">if</span> (to.path === <span class="hljs-string">&#x27;/login&#x27;</span>) &#123;      next(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span> &#125;);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">if</span> (store.getters.roles.length === <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 判断当前用户是否已拉取完user_info信息</span>        store.dispatch(<span class="hljs-string">&#x27;GetInfo&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123; <span class="hljs-comment">// 拉取info</span>          <span class="hljs-keyword">const</span> roles = res.data.role;          store.dispatch(<span class="hljs-string">&#x27;GenerateRoutes&#x27;</span>, &#123; roles &#125;).then(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">// 生成可访问的路由表</span>            router.addRoutes(store.getters.addRouters) <span class="hljs-comment">// 动态添加可访问路由表</span>            next(&#123; ...to, <span class="hljs-attr">replace</span>: <span class="hljs-literal">true</span> &#125;) <span class="hljs-comment">// hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record</span>          &#125;)        &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;          <span class="hljs-built_in">console</span>.log(err);        &#125;);      &#125; <span class="hljs-keyword">else</span> &#123;        next() <span class="hljs-comment">//当有用户权限的时候，说明所有可访问路由已生成 如访问没权限的全面会自动进入404页面</span>      &#125;    &#125;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">if</span> (whiteList.indexOf(to.path) !== -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 在免登录白名单，直接进入</span>      next();    &#125; <span class="hljs-keyword">else</span> &#123;      next(<span class="hljs-string">&#x27;/login&#x27;</span>); <span class="hljs-comment">// 否则全部重定向到登录页</span>    &#125;  &#125;&#125;);</code></pre><h3 id="store-permission-js"><a href="#store-permission-js" class="headerlink" title="store/permission.js"></a>store/permission.js</h3><pre><code class="hljs js"><span class="hljs-comment">// store/permission.js</span><span class="hljs-keyword">import</span> &#123; asyncRouterMap, constantRouterMap &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;src/router&#x27;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasPermission</span>(<span class="hljs-params">roles, route</span>) </span>&#123;  <span class="hljs-keyword">if</span> (route.meta &amp;&amp; route.meta.role) &#123;    <span class="hljs-keyword">return</span> roles.some(<span class="hljs-function"><span class="hljs-params">role</span> =&gt;</span> route.meta.role.indexOf(role) &gt;= <span class="hljs-number">0</span>)  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>  &#125;&#125;<span class="hljs-keyword">const</span> permission = &#123;  state: &#123;    routers: constantRouterMap,    addRouters: []  &#125;,  mutations: &#123;    SET_ROUTERS: <span class="hljs-function">(<span class="hljs-params">state, routers</span>) =&gt;</span> &#123;      state.addRouters = routers;      state.routers = constantRouterMap.concat(routers);    &#125;  &#125;,  actions: &#123;    <span class="hljs-function"><span class="hljs-title">GenerateRoutes</span>(<span class="hljs-params">&#123; commit &#125;, data</span>)</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;        <span class="hljs-keyword">const</span> &#123; roles &#125; = data;        <span class="hljs-keyword">const</span> accessedRouters = asyncRouterMap.filter(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> &#123;          <span class="hljs-keyword">if</span> (roles.indexOf(<span class="hljs-string">&#x27;admin&#x27;</span>) &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;          <span class="hljs-keyword">if</span> (hasPermission(roles, v)) &#123;            <span class="hljs-keyword">if</span> (v.children &amp;&amp; v.children.length &gt; <span class="hljs-number">0</span>) &#123;              v.children = v.children.filter(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> &#123;                <span class="hljs-keyword">if</span> (hasPermission(roles, child)) &#123;                  <span class="hljs-keyword">return</span> child                &#125;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;              &#125;);              <span class="hljs-keyword">return</span> v            &#125; <span class="hljs-keyword">else</span> &#123;              <span class="hljs-keyword">return</span> v            &#125;          &#125;          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;);        commit(<span class="hljs-string">&#x27;SET_ROUTERS&#x27;</span>, accessedRouters);        resolve();      &#125;)    &#125;  &#125;&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> permission;</code></pre><p>这里的代码说白了就是干了一件事，通过用户的权限和之前在router.js里面asyncRouterMap的每一个页面所需要的权限做匹配，最后返回一个该用户能够访问路由有哪些。</p><h3 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h3><hr><p>最后一个涉及到权限的地方就是侧边栏，不过在前面的基础上已经很方便就能实现动态显示侧边栏了。这里侧边栏基于element-ui的NavMenu来实现的。 代码有点多不贴详细的代码了，有兴趣的可以直接去github上看<a href="https://github.com/PanJiaChen/vue-element-admin/tree/master/src/views/layout/components/Sidebar" target="_blank" rel="noopener">地址</a>，或者直接看关于侧边栏的<a href="https://panjiachen.github.io/vue-element-admin-site/#/router-and-nav" target="_blank" rel="noopener">文档</a>。</p><p>说白了就是遍历之前算出来的<code>permission_routers</code>，通过vuex拿到之后动态v-for渲染而已。不过这里因为有一些业务需求所以加了很多判断 比如我们在定义路由的时候会加很多参数</p><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment">* hidden: true                   if `hidden:true` will not show in the sidebar(default is false)</span><span class="hljs-comment">* redirect: noredirect           if `redirect:noredirect` will no redirct in the breadcrumb</span><span class="hljs-comment">* name:&#x27;router-name&#x27;             the name is used by &lt;keep-alive&gt; (must set!!!)</span><span class="hljs-comment">* meta : &#123;</span><span class="hljs-comment">   role: [&#x27;admin&#x27;,&#x27;editor&#x27;]     will control the page role (you can set multiple roles)</span><span class="hljs-comment">   title: &#x27;title&#x27;               the name show in submenu and breadcrumb (recommend set)</span><span class="hljs-comment">   icon: &#x27;svg-name&#x27;             the icon show in the sidebar,</span><span class="hljs-comment">   noCache: true                if fasle ,the page will no be cached(default is false)</span><span class="hljs-comment"> &#125;</span><span class="hljs-comment">**/</span></code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端设置内容超出自动换行</title>
    <link href="/2021/05/19/workbreak/"/>
    <url>/2021/05/19/workbreak/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs js"><span class="hljs-comment">/*设置内容超出后自动换行*/</span>word-wrap: <span class="hljs-keyword">break</span>-word;word-<span class="hljs-keyword">break</span>: <span class="hljs-keyword">break</span>-all;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端拖拽两个盒模型</title>
    <link href="/2021/05/19/drag/"/>
    <url>/2021/05/19/drag/</url>
    
    <content type="html"><![CDATA[<p>拖拽线，下面的上下内容分区的比例会改变</p><p><img src="/2021/05/19/drag/1.png" srcset="/img/loading.gif" alt="柱状图1"></p><a id="more"></a><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;topDom&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;containorOuter&quot;</span>&gt;</span>上面<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;line&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;moveDom&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dragLine&quot;</span> /&gt;</span>  // 拖拽的线<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;bottomDom&quot;</span> &gt;</span>下面<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-built_in">this</span>.topDom = <span class="hljs-built_in">this</span>.$refs.topDom    <span class="hljs-keyword">const</span> _this = <span class="hljs-built_in">this</span>    <span class="hljs-built_in">this</span>.$nextTick(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-keyword">const</span> moveDom = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;line&#x27;</span>)      moveDom.onmousedown = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;        _this.clientStartX = e.clientY        <span class="hljs-built_in">document</span>.onmousemove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;          _this.moveHandle(e.clientY, _this.topDom)          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>        &#125;        <span class="hljs-built_in">document</span>.onmouseup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;          <span class="hljs-built_in">document</span>.onmousemove = <span class="hljs-literal">null</span>          <span class="hljs-built_in">document</span>.onmouseup = <span class="hljs-literal">null</span>        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>      &#125;    &#125;)  &#125;,  methods: &#123;    <span class="hljs-function"><span class="hljs-title">moveHandle</span>(<span class="hljs-params">nowClient, topDom</span>)</span> &#123;      <span class="hljs-keyword">let</span> changeHight = nowClient - <span class="hljs-number">103</span>      <span class="hljs-keyword">let</span> remainHight = <span class="hljs-built_in">document</span>.body.clientHeight - nowClient      <span class="hljs-comment">// 下面两个判断是控制拖动的最大范围，不能完全覆盖</span>      <span class="hljs-keyword">if</span> (changeHight &lt; <span class="hljs-number">100</span>) &#123;        changeHight = <span class="hljs-number">100</span>        nowClient = <span class="hljs-number">100</span> + <span class="hljs-number">103</span>        remainHight = <span class="hljs-built_in">document</span>.body.clientHeight - nowClient      &#125;      <span class="hljs-keyword">if</span> (remainHight &lt; <span class="hljs-number">100</span>) &#123;        remainHight = <span class="hljs-number">100</span>        nowClient = <span class="hljs-built_in">document</span>.body.clientHeight - <span class="hljs-number">100</span>        changeHight = <span class="hljs-built_in">document</span>.body.clientHeight - <span class="hljs-number">203</span>      &#125;      topDom.style.height = changeHight + <span class="hljs-string">&#x27;px&#x27;</span>      <span class="hljs-built_in">this</span>.$refs.bottomDom.style.height = remainHight + <span class="hljs-string">&#x27;px&#x27;</span>    &#125;,  &#125;</code></pre><pre><code class="hljs css">// 线的样式<span class="hljs-selector-class">.dragLine</span> &#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">2px</span>;    <span class="hljs-attribute">background</span>: <span class="hljs-number">#dcdfe6</span>;    <span class="hljs-attribute">cursor</span>: row-resize;&#125;</code></pre><p><a href="https://blog.csdn.net/u012767761/article/details/82712194" target="_blank" rel="noopener">https://blog.csdn.net/u012767761/article/details/82712194</a>  鼠标样式详情</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>通用的前端复制方法</title>
    <link href="/2021/05/14/copy/"/>
    <url>/2021/05/14/copy/</url>
    
    <content type="html"><![CDATA[<p>前端通用的copy方法:</p><a id="more"></a><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">copyUrl</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">const</span> aux = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;input&#x27;</span>)    aux.setAttribute(<span class="hljs-string">&#x27;value&#x27;</span>, <span class="hljs-built_in">this</span>.loginHerf)<span class="hljs-comment">// this.loginHerf是需要copy的东西</span>    <span class="hljs-built_in">document</span>.body.appendChild(aux)    aux.select()    <span class="hljs-built_in">document</span>.execCommand(<span class="hljs-string">&#x27;copy&#x27;</span>)    <span class="hljs-built_in">document</span>.body.removeChild(aux)    <span class="hljs-built_in">this</span>.$message(&#123;        type: <span class="hljs-string">&#x27;success&#x27;</span>,        message: <span class="hljs-string">&#x27;复制成功!&#x27;</span>    &#125;)&#125;,</code></pre><p>或者</p><p>使用插件clipboard.js</p><p>使用插件v-clipboard</p><pre><code class="hljs js"><span class="hljs-comment">//安装</span>npm install --save v-clipboard<span class="hljs-comment">//在main.js中引入</span><span class="hljs-keyword">import</span> Clipboard <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;v-clipboard&#x27;</span>Vue.use(Clipboard)<span class="hljs-comment">//使用</span>&lt;button v-clipboard=<span class="hljs-string">&quot;value&quot;</span>&gt;  Copy to clipboard&lt;/button&gt;或者&lt;button v-clipboard=<span class="hljs-string">&quot;() =&gt; value&quot;</span>&gt;  Copy to clipboard&lt;/button&gt;或者<span class="hljs-built_in">this</span>.$clipboard(value)<span class="hljs-comment">//回调事件</span>&lt;template&gt;    &lt;button v-clipboard=<span class="hljs-string">&quot;foo&quot;</span>            v-clipboard:success=<span class="hljs-string">&quot;clipboardSuccessHandler&quot;</span> <span class="hljs-comment">// Success event handler </span>            v-clipboard:error=<span class="hljs-string">&quot;clipboardErrorHandler&quot;</span>&gt;    <span class="hljs-comment">// Error event handler</span>      Copy to clipboard    &lt;/button&gt;&lt;/template&gt;&lt;script&gt;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;    methods: &#123;    clipboardSuccessHandler (&#123; value, event &#125;) &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;success&#x27;</span>, value)    &#125;,    clipboardErrorHandler (&#123; value, event &#125;) &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;error&#x27;</span>, value)    &#125;  &#125;&#125;&lt;/script&gt;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>React入门（井字棋）</title>
    <link href="/2021/05/10/react/"/>
    <url>/2021/05/10/react/</url>
    
    <content type="html"><![CDATA[<p>React 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库。使用 React 可以将一些简短、独立的代码片段组合成复杂的 UI 界面，这些代码片段被称作“组件”。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./index.css&#x27;</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">return</span> (      &lt;button className=<span class="hljs-string">&quot;square&quot;</span> onClick=&#123;<span class="hljs-function">() =&gt;</span> &#123; alert(<span class="hljs-string">&#x27;cilck&#x27;</span>);  &#125;&#125;&gt;        &#123;<span class="hljs-built_in">this</span>.props.value&#125;        &#123;<span class="hljs-comment">/* TODO */</span>&#125;      &lt;/button&gt;    );  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Board</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">renderSquare</span>(<span class="hljs-params">i</span>)</span> &#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Square</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;i&#125;</span> /&gt;</span></span>;  &#125;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">const</span> status = <span class="hljs-string">&#x27;Next player: X&#x27;</span>;    <span class="hljs-keyword">return</span> (      &lt;div&gt;        &lt;div className=<span class="hljs-string">&quot;status&quot;</span>&gt;&#123;status&#125;&lt;/div&gt;        &lt;div className=<span class="hljs-string">&quot;board-row&quot;</span>&gt;          &#123;<span class="hljs-built_in">this</span>.renderSquare(<span class="hljs-number">0</span>)&#125;          &#123;<span class="hljs-built_in">this</span>.renderSquare(<span class="hljs-number">1</span>)&#125;          &#123;<span class="hljs-built_in">this</span>.renderSquare(<span class="hljs-number">2</span>)&#125;        &lt;/div&gt;        &lt;div className=<span class="hljs-string">&quot;board-row&quot;</span>&gt;          &#123;<span class="hljs-built_in">this</span>.renderSquare(<span class="hljs-number">3</span>)&#125;          &#123;<span class="hljs-built_in">this</span>.renderSquare(<span class="hljs-number">4</span>)&#125;          &#123;<span class="hljs-built_in">this</span>.renderSquare(<span class="hljs-number">5</span>)&#125;        &lt;/div&gt;        &lt;div className=<span class="hljs-string">&quot;board-row&quot;</span>&gt;          &#123;<span class="hljs-built_in">this</span>.renderSquare(<span class="hljs-number">6</span>)&#125;          &#123;<span class="hljs-built_in">this</span>.renderSquare(<span class="hljs-number">7</span>)&#125;          &#123;<span class="hljs-built_in">this</span>.renderSquare(<span class="hljs-number">8</span>)&#125;        &lt;/div&gt;      &lt;/div&gt;    );  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Game</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">return</span> (      &lt;div className=<span class="hljs-string">&quot;game&quot;</span>&gt;        &lt;div className=<span class="hljs-string">&quot;game-board&quot;</span>&gt;          &lt;Board /&gt;        &lt;/div&gt;        &lt;div className=<span class="hljs-string">&quot;game-info&quot;</span>&gt;          &lt;div&gt;&#123;<span class="hljs-comment">/* status */</span>&#125;&lt;/div&gt;          &lt;ol&gt;&#123;<span class="hljs-comment">/* TODO */</span>&#125;&lt;/ol&gt;        &lt;/div&gt;      &lt;/div&gt;    );  &#125;&#125;<span class="hljs-comment">// ========================================</span>ReactDOM.render(  &lt;Game /&gt;,  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>));</code></pre><p>建立方块。</p><p><strong>注意</strong></p><p>在 JavaScript class中，每次你定义其子类的构造函数时，都需要调用 <code>super</code> 方法。因此，在所有含有构造函数的的 React 组件中，构造函数必须以 <code>super(props)</code> 开头。</p><h3 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h3><p>在 <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en" target="_blank" rel="noopener">Chrome</a> 或者 <a href="https://addons.mozilla.org/en-US/firefox/addon/react-devtools/" target="_blank" rel="noopener">Firefox</a> 中安装扩展 React Devtools 可以让你在浏览器开发者工具中查看 React 的组件树。</p><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./index.css&#x27;</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-comment">// constructor(props) &#123;</span>  <span class="hljs-comment">//   super(props);</span>  <span class="hljs-comment">//   this.state = &#123;</span>  <span class="hljs-comment">//     value: null,</span>  <span class="hljs-comment">//   &#125;</span>  <span class="hljs-comment">// &#125;</span>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">return</span> (      &lt;button        className=<span class="hljs-string">&quot;square&quot;</span>        onClick=&#123;<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-built_in">this</span>.props.onClick()  &#125;&#125;&gt;        &#123;<span class="hljs-built_in">this</span>.props.value&#125;        &#123;<span class="hljs-comment">/* TODO */</span>&#125;      &lt;/button&gt;    );  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Board</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;    <span class="hljs-built_in">super</span>(props);    <span class="hljs-built_in">this</span>.state = &#123;      squares: <span class="hljs-built_in">Array</span>(<span class="hljs-number">9</span>).fill(<span class="hljs-literal">null</span>),      xIsNext: <span class="hljs-literal">true</span>,    &#125;;  &#125;  <span class="hljs-function"><span class="hljs-title">handleClick</span>(<span class="hljs-params">i</span>)</span> &#123;    <span class="hljs-keyword">const</span> squares = <span class="hljs-built_in">this</span>.state.squares.slice();    <span class="hljs-keyword">if</span> (calculateWinner(squares) || squares[i]) &#123;      <span class="hljs-keyword">return</span>;    &#125;    squares[i] = <span class="hljs-built_in">this</span>.state.xIsNext ? <span class="hljs-string">&#x27;X&#x27;</span> : <span class="hljs-string">&#x27;O&#x27;</span>;    <span class="hljs-comment">// squares[i] = &#x27;X&#x27;;</span>    <span class="hljs-built_in">this</span>.setState(&#123;      squares: squares,      xIsNext: !<span class="hljs-built_in">this</span>.state.xIsNext,    &#125;);  &#125;  <span class="hljs-function"><span class="hljs-title">renderSquare</span>(<span class="hljs-params">i</span>)</span> &#123;    <span class="hljs-keyword">return</span> (      &lt;Square         value=&#123;<span class="hljs-built_in">this</span>.state.squares[i]&#125;        onClick=&#123;<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.handleClick(i)&#125;      /&gt;    )  &#125;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">const</span> winner = calculateWinner(<span class="hljs-built_in">this</span>.state.squares);    <span class="hljs-keyword">let</span> status;    <span class="hljs-keyword">if</span> (winner) &#123;      status = <span class="hljs-string">&#x27;Winner: &#x27;</span> + winner;    &#125; <span class="hljs-keyword">else</span> &#123;      status = <span class="hljs-string">&#x27;Next player: &#x27;</span> + (<span class="hljs-built_in">this</span>.state.xIsNext ? <span class="hljs-string">&#x27;X&#x27;</span> : <span class="hljs-string">&#x27;O&#x27;</span>);    &#125;    <span class="hljs-comment">// const status = &#x27;Next player: &#x27; + (this.state.xIsNext ? &#x27;X&#x27; : &#x27;O&#x27;);</span>    <span class="hljs-keyword">return</span> (      &lt;div&gt;        &lt;div className=<span class="hljs-string">&quot;status&quot;</span>&gt;&#123;status&#125;&lt;/div&gt;        &lt;div className=<span class="hljs-string">&quot;board-row&quot;</span>&gt;          &#123;<span class="hljs-built_in">this</span>.renderSquare(<span class="hljs-number">0</span>)&#125;          &#123;<span class="hljs-built_in">this</span>.renderSquare(<span class="hljs-number">1</span>)&#125;          &#123;<span class="hljs-built_in">this</span>.renderSquare(<span class="hljs-number">2</span>)&#125;        &lt;/div&gt;        &lt;div className=<span class="hljs-string">&quot;board-row&quot;</span>&gt;          &#123;<span class="hljs-built_in">this</span>.renderSquare(<span class="hljs-number">3</span>)&#125;          &#123;<span class="hljs-built_in">this</span>.renderSquare(<span class="hljs-number">4</span>)&#125;          &#123;<span class="hljs-built_in">this</span>.renderSquare(<span class="hljs-number">5</span>)&#125;        &lt;/div&gt;        &lt;div className=<span class="hljs-string">&quot;board-row&quot;</span>&gt;          &#123;<span class="hljs-built_in">this</span>.renderSquare(<span class="hljs-number">6</span>)&#125;          &#123;<span class="hljs-built_in">this</span>.renderSquare(<span class="hljs-number">7</span>)&#125;          &#123;<span class="hljs-built_in">this</span>.renderSquare(<span class="hljs-number">8</span>)&#125;        &lt;/div&gt;      &lt;/div&gt;    );  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Game</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">return</span> (      &lt;div className=<span class="hljs-string">&quot;game&quot;</span>&gt;        &lt;div className=<span class="hljs-string">&quot;game-board&quot;</span>&gt;          &lt;Board /&gt;        &lt;/div&gt;        &lt;div className=<span class="hljs-string">&quot;game-info&quot;</span>&gt;          &lt;div&gt;&#123;<span class="hljs-comment">/* status */</span>&#125;&lt;/div&gt;          &lt;ol&gt;&#123;<span class="hljs-comment">/* TODO */</span>&#125;&lt;/ol&gt;        &lt;/div&gt;      &lt;/div&gt;    );  &#125;&#125;<span class="hljs-comment">// ========================================</span>ReactDOM.render(  &lt;Game /&gt;,  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>));<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calculateWinner</span>(<span class="hljs-params">squares</span>) </span>&#123;  <span class="hljs-keyword">const</span> lines = [    [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],    [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>],    [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>],    [<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>],    [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>],    [<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>],    [<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>],    [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>],  ];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; lines.length; i++) &#123;    <span class="hljs-keyword">const</span> [a, b, c] = lines[i];    <span class="hljs-keyword">if</span> (squares[a] &amp;&amp; squares[a] === squares[b] &amp;&amp; squares[a] === squares[c]) &#123;      <span class="hljs-keyword">return</span> squares[a];    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>右箭头CSS</title>
    <link href="/2021/05/07/rightArrow/"/>
    <url>/2021/05/07/rightArrow/</url>
    
    <content type="html"><![CDATA[<p>右箭头的样式，可以用&gt;这个，也可以用css，css更容易更改样式和调整。</p><pre><code class="hljs js">.right-arrow &#123;      display :inline-block;    position: relative;    width: 14px;    height: 26px;    margin-right: 20px;&#125;.right-arrow::after &#123;    display: inline-block;    content: <span class="hljs-string">&quot; &quot;</span>;    height: 13px;    width: 13px;    border-width: 3px 3px <span class="hljs-number">0</span> <span class="hljs-number">0</span>;    border-color: #979797;    border-style: solid;    transform: matrix(<span class="hljs-number">0.71</span>, <span class="hljs-number">0.71</span>, -<span class="hljs-number">0.71</span>, <span class="hljs-number">0.71</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    position: absolute;    top: <span class="hljs-number">50</span>%;    left: <span class="hljs-number">700</span> * @base;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Echarts的X轴数据过多时</title>
    <link href="/2021/04/23/echars4-23/"/>
    <url>/2021/04/23/echars4-23/</url>
    
    <content type="html"><![CDATA[<p> 在使用echarts 图表的时候发现要展示的数据过多，数据都挤压在一块</p><a id="more"></a><pre><code class="hljs js">yAxis: &#123;    type: <span class="hljs-string">&#x27;category&#x27;</span>,    data: [<span class="hljs-string">&#x27;张小勇1&#x27;</span>,<span class="hljs-string">&#x27;李思思2&#x27;</span>,<span class="hljs-string">&#x27;张明明3&#x27;</span>],    axisLabel:&#123;      interval:<span class="hljs-number">0</span>,       rotate:<span class="hljs-number">45</span>    &#125;&#125;</code></pre><pre><code class="hljs js">dataZoom: [&#123;    type: <span class="hljs-string">&#x27;inside&#x27;</span>,    start: <span class="hljs-number">50</span>,    end: <span class="hljs-number">100</span>&#125;, &#123;    start: <span class="hljs-number">0</span>,    end: <span class="hljs-number">10</span>&#125;],</code></pre><p>这样设置即可</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>防抖节流</title>
    <link href="/2021/04/13/debounce/"/>
    <url>/2021/04/13/debounce/</url>
    
    <content type="html"><![CDATA[<p>被触发的频次非常高，间隔很近，有可能造成其他的问题，这个时候需要防抖节流</p><h6 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h6><p>规定函数至少间隔多久执行。</p><ul><li><p>函数执行过一次后，在n秒内不能再次执行，否则推迟函数执行</p></li><li><p>下一次函数调用将清除上一次的定时器，并用setTimeout重新计时</p></li></ul><table><thead><tr><th>例子</th><th>未使用函数防抖</th><th>使用函数防抖</th></tr></thead><tbody><tr><td>当窗口大小发生变化时计算新的窗口大小</td><td>窗口大小改变就计算大小</td><td>窗口大小改变完成后计算大小</td></tr><tr><td>验证用户输入</td><td>用户每输入一个字符就进行验证</td><td>用户输入完成后进行验证</td></tr></tbody></table><h6 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h6><p>规定函数在某时间段内最多执行一次</p><ul><li>函数在n秒内最多执行一次</li><li>下一次函数调用将清除上一次的定时器</li><li>若函数执行的时间间隔小于等于规定时间间隔则用setTimeout在规定时间后再执行</li><li>若函数执行的时间间隔大于规定时间间隔则执行函数，并重新计时</li></ul><table><thead><tr><th>例子</th><th>未使用函数节流</th><th>使用函数节流</th></tr></thead><tbody><tr><td>页面滚动图片懒加载</td><td>每次都会执行事件处理程序</td><td>指定事件处理程序的执行频率</td></tr></tbody></table><p>何时使用函数防抖、何时使用函数节流看需求：</p><ul><li>当我们只需要处理最后一次触发事件时，用函数防抖。如窗口大小值变化时并不需要计算中间变化的过程，只需要窗口大小改变完成后的值</li><li>当事件触发过于频繁，我们需要限制事件处理程序的调用频率时，用函数节流。</li></ul><pre><code class="hljs js"><span class="hljs-comment">// 防抖</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_debounce</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;    <span class="hljs-keyword">var</span> delay = delay || <span class="hljs-number">200</span>;    <span class="hljs-keyword">var</span> timer;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">var</span> th = <span class="hljs-built_in">this</span>;        <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>;        <span class="hljs-keyword">if</span> (timer) &#123;            <span class="hljs-built_in">clearTimeout</span>(timer);        &#125;        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            timer = <span class="hljs-literal">null</span>;            fn.apply(th, args);        &#125;, delay);    &#125;;&#125;</code></pre><pre><code class="hljs js"><span class="hljs-comment">// 节流</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_throttle</span>(<span class="hljs-params">fn, interval</span>) </span>&#123;    <span class="hljs-keyword">var</span> last;    <span class="hljs-keyword">var</span> timer;    <span class="hljs-keyword">var</span> interval = interval || <span class="hljs-number">200</span>;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">var</span> th = <span class="hljs-built_in">this</span>;        <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>;        <span class="hljs-keyword">var</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();        <span class="hljs-keyword">if</span> (last &amp;&amp; now - last &lt; interval) &#123;            <span class="hljs-built_in">clearTimeout</span>(timer);            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;                last = now;                fn.apply(th, args);            &#125;, interval);        &#125; <span class="hljs-keyword">else</span> &#123;            last = now;            fn.apply(th, args);        &#125;    &#125;&#125;</code></pre><p>在需要使用的组件引用</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; _debounce &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;...&quot;</span>;</code></pre><p>在 <code>methods</code> 中使用</p><pre><code class="hljs js">methods: &#123;  changefield: _debounce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_type, index, item</span>) </span>&#123;      <span class="hljs-comment">// do something ...</span>  &#125;, <span class="hljs-number">200</span>)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端性能优化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Echart表格如何显示范围图</title>
    <link href="/2021/04/12/rangeOfEchart/"/>
    <url>/2021/04/12/rangeOfEchart/</url>
    
    <content type="html"><![CDATA[<p>Ecahrt提供的柱状图一般的x轴都在柱形的中间，如下图</p><a id="more"></a><p><img src="/2021/04/12/rangeOfEchart/1.png" srcset="/img/loading.gif" alt="柱状图1"></p><p>但是如果是需要让柱形图在x轴数值的区间的话，则可以在echart的xAxis中设置两个数组，一个是使用Y的数组值，这个是相当于对齐中间，另一个是那个区间的数组，一般区间数组要比正常的Y轴多那么一个值，要么最左边，要么最右边。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> xData = [<span class="hljs-string">&#x27;00:00&#x27;</span>, <span class="hljs-string">&#x27;01:00&#x27;</span>, <span class="hljs-string">&#x27;02:00&#x27;</span>, <span class="hljs-string">&#x27;03:00&#x27;</span>, <span class="hljs-string">&#x27;04:00&#x27;</span>, <span class="hljs-string">&#x27;05:00&#x27;</span>, <span class="hljs-string">&#x27;06:00&#x27;</span>];<span class="hljs-keyword">const</span> barData = [<span class="hljs-number">5</span>, <span class="hljs-number">20</span>, <span class="hljs-number">36</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>];option = &#123;    tooltip: &#123;        show: <span class="hljs-literal">true</span>,        trigger: <span class="hljs-string">&#x27;axis&#x27;</span>,        confine: <span class="hljs-literal">true</span>,    &#125;,    xAxis: [&#123;            data: barData,            show:<span class="hljs-literal">false</span>        &#125;,        &#123;            data: xData,            axisLabel: &#123;                interval: <span class="hljs-number">0</span>,                show: <span class="hljs-literal">true</span>,            &#125;,            position: <span class="hljs-string">&#x27;bottom&#x27;</span>,            boundaryGap: <span class="hljs-literal">false</span>,            axisPointer: &#123;                show: <span class="hljs-literal">false</span>,            &#125;,        &#125;,    ],    yAxis: &#123;        type: <span class="hljs-string">&#x27;value&#x27;</span>,        show: <span class="hljs-literal">false</span>,    &#125;,    series: [&#123;        data: barData,        type: <span class="hljs-string">&#x27;bar&#x27;</span>,        backgroundStyle: &#123;            color: <span class="hljs-string">&#x27;rgba(220, 220, 220, 0.8)&#x27;</span>,        &#125;,    &#125;, ],&#125;</code></pre><p>如下图</p><p><img src="/2021/04/12/rangeOfEchart/2.png" srcset="/img/loading.gif" alt="柱状图2"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端传值时数字变量相加变成字符串拼接</title>
    <link href="/2021/04/09/%E5%89%8D%E7%AB%AF%E4%BC%A0%E5%80%BC%E6%97%B6%E6%95%B0%E5%AD%97%E5%8F%98%E9%87%8F%E7%9B%B8%E5%8A%A0%E7%BC%BA%E5%8F%98%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5/"/>
    <url>/2021/04/09/%E5%89%8D%E7%AB%AF%E4%BC%A0%E5%80%BC%E6%97%B6%E6%95%B0%E5%AD%97%E5%8F%98%E9%87%8F%E7%9B%B8%E5%8A%A0%E7%BC%BA%E5%8F%98%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<p>今天答题计时功能前端给后端传时间这个值的时候，因为是两个值分别控制一个总时间（一个是已经作答的时间，另一个是存在的时间）两个数值用+相连，但是后台收到的却是字符串的拼接，这就导致了时间这个变量平白无故的很大，后面才知道需要<code>Numbe()</code>一下，<code>new Numbe()</code>和<code>Numbe()</code>还是有区别的。如果不用 new 运算符，把 Number() 作为一个函数来调用，它将把自己的参数转换成一个原始的数值，并且返回这个值（如果转换失败，则返回 NaN），Number() 和运算符 new 一起作为构造函数使用时，它返回一个新创建的 Number 对象</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>答题计时功能</title>
    <link href="/2021/04/08/%E7%AD%94%E9%A2%98%E8%AE%A1%E6%97%B6%E5%8A%9F%E8%83%BD/"/>
    <url>/2021/04/08/%E7%AD%94%E9%A2%98%E8%AE%A1%E6%97%B6%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<p>一个答题的网页端需要增加一个答题计时的功能，功能比较简单，但是需求是如果当前浏览器失焦的话便停止计时。</p><p>目前的想法是前端进行计时，然后定时返回给后端进行存储，后续如果关闭重新打开浏览器从后台读取保存的答题时间数据，虽然考虑到“永远不要相信用户的输入”，但是这个相对来说实现比较快速。</p><p>实现的方法如下：</p><p>在全局的vue页面中，引入一个用来计数的字段，如count，在vue的mounted函数中加入如下代码</p><pre><code class="hljs js"><span class="hljs-comment">// 监听当前页面 显示状态</span><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;visibilitychange&#x27;</span>, <span class="hljs-built_in">this</span>.hanldeVisiblityChange);<span class="hljs-comment">// 当页面被销毁时 移除监听</span><span class="hljs-built_in">this</span>.$on(<span class="hljs-string">&#x27;hook:beforeDestroy&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&#x27;ws 我被销毁了, 移除监听&gt;&gt;&gt;&#x27;</span>);    <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">&#x27;visibilitychange&#x27;</span>, <span class="hljs-built_in">this</span>.hanldeVisiblityChange)&#125;)</code></pre><p>增加一个销毁函数</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">beforeDestroy</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&#x27;ws 我被销毁了,vue生命周期 &gt;&gt;&gt;&#x27;</span>);&#125;,</code></pre><p>接着在methods中增加</p><pre><code class="hljs javascript">  <span class="hljs-function"><span class="hljs-title">total</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-built_in">this</span>.count++;    <span class="hljs-built_in">document</span>.title = <span class="hljs-built_in">this</span>.count;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.count)  &#125;,    <span class="hljs-function"><span class="hljs-title">hanldeVisiblityChange</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.visibilityState === <span class="hljs-string">&#x27;hidden&#x27;</span>) &#123;          <span class="hljs-built_in">clearInterval</span>(<span class="hljs-built_in">this</span>.time);          <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&#x27;ws  hidden&gt;&gt;&gt;关闭定时器&#x27;</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.visibilityState === <span class="hljs-string">&#x27;visible&#x27;</span>) &#123;            <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&#x27;ws  visible&gt;&gt;&gt;启动定时器&#x27;</span>);            <span class="hljs-built_in">this</span>.time=<span class="hljs-built_in">setInterval</span>(<span class="hljs-built_in">this</span>.total,<span class="hljs-number">1000</span>);        &#125;    &#125;&#125;</code></pre><p>然后便可以监听当前窗口是否在使用，后续可以加入答题时间上传的功能等。</p><p>过了一天写完代码后，在获取到后台的已经作答时间以后就要调用这个定时器的判断，但是却不能够再监听当前页面的状态了，这个时候要在这个监听函数里进行清空定时器的操作，不管有没有，只要进hanldeVisiblityChange()这个函数就清空定时器，这样便解决了这个不能监听状态的问题。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>本地图片不显示问题</title>
    <link href="/2021/04/07/localPictorCantShow/"/>
    <url>/2021/04/07/localPictorCantShow/</url>
    
    <content type="html"><![CDATA[<p>今天想测试使用md加入图片，发现npm build以后的路径会出错，查百度是说由于hexo的版本升级后导致路径不对，可以使用修改后的hexo-asset-image插件来解决这个问题.。<a id="more"></a>将修改好的仓库代码fork到了自己的git仓库，使用</p><p><code>npm install https://github.com/shiyanmaia/hexo-asset-image.git --save</code></p><p>来进行安装，git推送以后如果使用<code>![](相对路径)</code>来显示图片会使用一个奇怪的路径，且使用的是github的绝对路径，经过排查发现是_config.yml的配置错误，其中URL的配置没有配置对</p><img src="/2021/04/07/localPictorCantShow/1.jpg" srcset="/img/loading.gif" class><p>如上图修改正确以后，便可以使用<code>![](相对路径)</code>来引入图片了，官方引入图片方法是</p><pre><code class="hljs markdown">&#123;% asset<span class="hljs-emphasis">_img test.jpg [width] [height] This is an test image %&#125;</span></code></pre><p>不要使用中文路径，虽然经过验证，中文.md也可以正常使用，但是插入图片的话可能会有错误。</p>]]></content>
    
    
    <categories>
      
      <category>hexo的问题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue响应式自适应高度</title>
    <link href="/2021/04/07/calcHeight/"/>
    <url>/2021/04/07/calcHeight/</url>
    
    <content type="html"><![CDATA[<p>解决vue中组件不能实时更新高度问题</p><a id="more"></a><p>在vue.mixin中添加<br>  <pre><code class="hljs js">componentHeight: <span class="hljs-number">0</span>,componentWidth: <span class="hljs-number">0</span>,</code></pre><br>  mounted中添加</p><pre><code class="hljs js">mounted: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.$options.calcHeight) &#123;        <span class="hljs-built_in">this</span>.calcHeight()        <span class="hljs-keyword">const</span> resizeHandler = util.debounce(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-built_in">this</span>.calcHeight()        &#125;, <span class="hljs-number">200</span>)        <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;resize&#x27;</span>, resizeHandler)        <span class="hljs-built_in">this</span>.$on(<span class="hljs-string">&#x27;hook:beforeDestroy&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">&#x27;resize&#x27;</span>, resizeHandler)        &#125;)    &#125;&#125;</code></pre><p>  methods中添加</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">calcHeight</span>(<span class="hljs-params"></span>)</span> &#123;  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.$options.calcHeight) &#123;    <span class="hljs-keyword">return</span>  &#125;  <span class="hljs-built_in">clearInterval</span>(<span class="hljs-built_in">this</span>._inner_timer)  <span class="hljs-built_in">this</span>._inner_timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.$el &amp;&amp; <span class="hljs-built_in">this</span>.$el.getClientRects &amp;&amp; <span class="hljs-built_in">this</span>.$el.getClientRects() &amp;&amp; <span class="hljs-built_in">this</span>.$el.getClientRects()[<span class="hljs-number">0</span>]) &#123;      <span class="hljs-keyword">const</span> h = <span class="hljs-built_in">this</span>.$el.getClientRects()[<span class="hljs-number">0</span>].height      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isNaN</span>(h)) &#123;        <span class="hljs-built_in">clearInterval</span>(<span class="hljs-built_in">this</span>._inner_timer)        <span class="hljs-built_in">this</span>.componentHeight = h        <span class="hljs-built_in">this</span>.componentWidth = <span class="hljs-built_in">this</span>.$el.getClientRects()[<span class="hljs-number">0</span>].width        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.$options.calcHeightSuccess) &#123;          <span class="hljs-built_in">this</span>[<span class="hljs-built_in">this</span>.$options.calcHeightSuccess]()        &#125;      &#125;    &#125;  &#125;, <span class="hljs-number">10</span>)&#125;,</code></pre><p>引入一个插件js</p><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  debounce (func, wait) &#123;    <span class="hljs-keyword">let</span> timeout, args, context, timestamp, result    <span class="hljs-keyword">const</span> later = <span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-keyword">const</span> last = <span class="hljs-built_in">Date</span>.now() - timestamp      <span class="hljs-keyword">if</span> (last &lt; wait &amp;&amp; last &gt; <span class="hljs-number">0</span>) &#123;        timeout = <span class="hljs-built_in">setTimeout</span>(later, wait - last)      &#125; <span class="hljs-keyword">else</span> &#123;        timeout = <span class="hljs-literal">null</span>        result = func.apply(context, args)        context = args = <span class="hljs-literal">null</span>      &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...argArr</span>) </span>&#123;      context = <span class="hljs-built_in">this</span>      args = argArr      timestamp = <span class="hljs-built_in">Date</span>.now()      <span class="hljs-keyword">if</span> (!timeout) &#123; <span class="hljs-comment">// 延时不存在，即第一次调用</span>        timeout = <span class="hljs-built_in">setTimeout</span>(later, wait)      &#125;      <span class="hljs-keyword">return</span> result    &#125;  &#125; &#125;</code></pre><p>接下来在需要使用计算的页面中设置<code>calcHeight:true</code>,然后便可以监控到<code>componentHeight</code>的变化</p>]]></content>
    
    
    <categories>
      
      <category>前端样式问题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Markdown中mermaid的使用(流程图)</title>
    <link href="/2021/04/07/Markdown%E4%B8%ADmermaid%E7%9A%84%E4%BD%BF%E7%94%A8-%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    <url>/2021/04/07/Markdown%E4%B8%ADmermaid%E7%9A%84%E4%BD%BF%E7%94%A8-%E6%B5%81%E7%A8%8B%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>Markdown 语法并不直接支持画图<br>但是可以引入mermaid插件</p><a id="more"></a><pre><code class="hljs markdown"><span class="hljs-code">```mermaid</span><span class="hljs-code">graph LR;</span><span class="hljs-code">　　Portal--&gt;|发布/更新配置|Apollo配置中心;</span><span class="hljs-code">　　Apollo配置中心--&gt;|实时推送|App;</span><span class="hljs-code">　　App--&gt;|实时查询|Apollo配置中心;</span><span class="hljs-code">```</span></code></pre><pre><code class="hljs mermaid">graph LR;  　　A--&gt;B;    　　A--&gt;C;  　　B--&gt;D;  　　C--&gt;D;</code></pre><font size="2">具体使用参考:<p><a href="https://blog.csdn.net/fenghuizhidao/article/details/79440583" target="_blank" rel="noopener">https://blog.csdn.net/fenghuizhidao/article/details/79440583</a><br><a href="https://www.cnblogs.com/nanqiang/p/8244309.html" target="_blank" rel="noopener">https://www.cnblogs.com/nanqiang/p/8244309.html</a></p></font>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何删除GitHub中的所有提交历史记录？</title>
    <link href="/2021/04/06/%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4GitHub%E4%B8%AD%E6%8F%90%E4%BA%A4%E7%9A%84%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/04/06/%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4GitHub%E4%B8%AD%E6%8F%90%E4%BA%A4%E7%9A%84%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>删除.git文件夹可能会导致git存储库中的问题<br>如果要删除所有提交历史记录，但将代码保持在当前状态，可以按照以下方式安全地执行此操作：</p><a id="more"></a><pre><code class="hljs JS">git checkout --orphan latest_branch <span class="hljs-comment">// 尝试  运行  </span>git add -A <span class="hljs-comment">// 添加所有文件</span>git commit -am <span class="hljs-string">&quot;commit message&quot;</span> <span class="hljs-comment">// 提交更改</span>git branch -D master <span class="hljs-comment">// 删除分支</span>git branch -m master <span class="hljs-comment">// 将当前分支重命名</span>git push -f origin master <span class="hljs-comment">// 最后，强制更新存储库</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>gitHub的使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gitHub的使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端开发环境</title>
    <link href="/2020/09/07/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <url>/2020/09/07/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<ol><li>git-fork,用于代码版本管理<a id="more"></a></li><li>nodeJs</li><li>nvm,用于切换node版本</li><li>nrm,用于快速切换npm的镜像</li><li>VS Code 或 HBuilderX</li><li>Switch Host,切换host开发环境</li><li>本地Git, git bash, windows terminal</li></ol>]]></content>
    
    
    <categories>
      
      <category>前端环境相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HELLO WORLD</title>
    <link href="/2020/08/06/HELLOW%20WORLD/"/>
    <url>/2020/08/06/HELLOW%20WORLD/</url>
    
    <content type="html"><![CDATA[<p>这是一个由hexo搭建的网站，使用fluid风格主题。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
